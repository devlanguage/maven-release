synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。
	1.某个线程在等待一个锁的控制权的这段时间需要中断
	2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程
	3.具有公平锁功能，每个到来的线程都将排队等候
	
下面细细道来……
先说第一种情况，
	ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。
	比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，
B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。
这个时候ReentrantLock就提供了2种机制，
	第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；
	第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。


